AuthController.ts

import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';
import { NextFunction, Request, Response, Router } from 'express';

import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { AuthApplicationService } from '../ApplicationService/AuthApplicationService';
import { handleResponse } from '../infrastructure/response';
import Book, { IBook } from '../Domain/Book/Book';

export const Injector = Symbol.for('AuthApplicationService');
@injectable()
export class AuthController {
    constructor(@inject('AuthApplicationService') public authApplicationService: AuthApplicationService) {}

    @errorHandlerMiddleware
    async register(req: Request, res: Response): Promise<void> {
        const { name, email, password } = req.body;
        const result = await this.authApplicationService.registerUser(name, email, password, res);

        handleResponse(res, 201, { user: result }, 'User registered successfully');
    }

    @errorHandlerMiddleware
    async listBooksUsers(req: Request, res: Response): Promise<void> {
        const books = await this.authApplicationService.listBooksUsers(res);

        handleResponse(res, 200, { books }, 'Books listed for users');
    }

    @errorHandlerMiddleware
    async login(req: Request, res: Response): Promise<void> {
        const { email, password } = req.body;
        const result = await this.authApplicationService.loginUser(email, password, res);

        handleResponse(res, 200, { token: result }, 'Login successful');
    }
}

_____________________________________________________________________________
AuthApplicationService.ts
 


import AuthService from '../Domain/User/Auth.service';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';
import { Request, Response } from 'express';
import TransactionHandler from '../infrastructure/Transaction/TransactionManager';

export const Injector = Symbol.for('AuthApplicationService');
@injectable()
export class AuthApplicationService {
    constructor(@inject(AuthService) private authService: AuthService, @inject(TransactionHandler) private transactionhandler: TransactionHandler) {}

    @errorHandlerMiddleware
    async registerUser(name: string, email: string, password: string, res: Response): Promise<void> {
        const user = await this.authService.registerUser(name, email, password, res);

        res.status(201).json({ user });
    }

    @errorHandlerMiddleware
    async listBooksUsers(res: Response): Promise<void> {
        await this.transactionhandler.runInTransaction(async (session) => {
            const books = await this.authService.listBooksUsers();

            res.status(200).json({
                books
            });
        });
    }

    @errorHandlerMiddleware
    async loginUser(email: string, password: string, res: Response): Promise<string> {
        const token = await this.authService.loginUser(email, password, res);
        return token;
    }
}

export default AuthApplicationService;


_____________________________________________________________________________
AUthService.ts

 
// AuthService.ts

import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { Response } from 'express';
import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware';
import { promisify } from 'util';
const jwt = require('jsonwebtoken');
import AuthRepository from './Auth.repository';
import { IAuthorModel } from './auth.entity';
import { handleResponse } from '../../infrastructure/response';
import { getConfig } from '../../infrastructure/config';

const compareAsync = promisify(require('bcrypt').compare);
const hashAsync = promisify(require('bcrypt').hash);

@injectable()
class AuthService {
    private readonly config = getConfig();

    constructor(@inject(AuthRepository) private authrepository: AuthRepository) {}

    @errorHandlerMiddleware
    async registerUser(name: string, email: string, password: string, res: Response): Promise<any> {
        if (typeof password !== 'string') {
            throw new Error('Password must be a string');
        }

        const existingUser = await this.authrepository.findUserByEmail(email);
        if (existingUser) {
            throw new Error('User with this email already exists');
        }

        const hashedPassword = await hashAsync(password + 'password:password' + name, 10);
        const user = await this.authrepository.registerUser(name, email, hashedPassword);

        return user;
    }

    @errorHandlerMiddleware
    async listBooksUsers(): Promise<unknown[]> {
        return this.authrepository.getAllBooks();
    }

    @errorHandlerMiddleware
    async loginUser(email: string, password: string, res: Response): Promise<string> {
        if (!email || !password) {
            res.status(400).json({ error: 'Email and password are required' });
            return '';
        }

        const user = await this.authrepository.findUserByEmailAndPassword(email, password);
        if (!user) {
            throw new Error('User not found');
        }

        const isPasswordValid = await compareAsync(password + 'sadasdda' + user.name, user.password);
        if (!isPasswordValid) {
            throw new Error('Invalid password');
        }

        const token = jwt.sign({ userId: user._id, email: user.email }, getConfig().secretKey, {
            expiresIn: '1h'
        });

        return token;
    }
}

export default AuthService;


_____________________________________________________________________________

AuthRepository.ts
 

import { injectable } from 'inversify';
import authEntity, { IAuthorModel } from './auth.entity';
import Book, { IBookModel } from '../Book/Book';

@injectable()
class AuthRepository {
    async findUserByEmail(email: string): Promise<IAuthorModel | null> {
        return authEntity.findOne({ email }).exec();
    }

    async registerUser(name: string, email: string, hashedPassword: string): Promise<IAuthorModel> {
        const user = new authEntity({ name, email, password: hashedPassword });
        return user.save();
    }

    async getAllBooks(): Promise<IBookModel[]> {
        return Book.find({}).exec();
    }

    async findUserById(userId: string): Promise<IAuthorModel | null> {
        return authEntity.findById(userId).exec();
    }

    async findUserByEmailAndPassword(email: string, password: string): Promise<IAuthorModel | null> {
        return authEntity.findOne({ email, password }).exec();
    }
}

export default AuthRepository;



_____________________________________________________________________________
Response.ts


import { Response } from 'express';

export const handleResponse = (res: Response, statusCode: number, data: any, message: string = '') => {
    res.status(statusCode).json({
        status: statusCode,
        data: data,
        message: message
    });
};


 
_____________________________________________________________________________

BookController.ts

 
 import { NextFunction, Request, Response } from 'express';
import 'reflect-metadata';
import { inject, injectable } from 'inversify';
import BookApplicationService from '../ApplicationService/BookApplicationService';
import { handleResponse } from '../infrastructure/response';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';

@injectable()
export class BookController {
    private bookApplicationservice: BookApplicationService;

    constructor(@inject(BookApplicationService) bookApplicationservice: BookApplicationService) {
        this.bookApplicationservice = bookApplicationservice;
    }

    createBook = async (req: Request, res: Response, next: NextFunction) => {
        const bookData = req.body;

        const createdBook = await this.bookApplicationservice.createBook(bookData, res);
        handleResponse(res, 201, { book: createdBook }, 'Book created successfully');
    };

    showAllBooks = async (req: Request, res: Response, next: NextFunction) => {
        const books = await this.bookApplicationservice.getAllBooks(res);
        handleResponse(res, 200, { books }, 'All books retrieved successfully');
    };

  
}

export default BookController;

 




_____________________________________________________________________________

BookApplicationService.ts
 


import BookService from '../Domain/Book/Book.service';
import Book, { IBook } from '../Domain/Book/Book';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { Response } from 'express';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';
import TransactionHandler from '../infrastructure/Transaction/TransactionManager';

@injectable()
export class BookApplicationService {
    private bookService: BookService;
    private transactionHandler: TransactionHandler;

    constructor(@inject(BookService) bookService: BookService, @inject(TransactionHandler) transactionHandler: TransactionHandler) {
        this.bookService = bookService;
        this.transactionHandler = transactionHandler;
    }

    @errorHandlerMiddleware
    async createBook(bookData: any, res: Response): Promise<any> {
        return this.transactionHandler.runInTransaction(async () => {
            const createdBook = await this.bookService.createBook(bookData, res);
            console.log(bookData);
            return createdBook;
        });
    }

    @errorHandlerMiddleware
    async getAllBooks(res: Response): Promise<any> {
        return this.transactionHandler.runInTransaction(async () => {
            const books = await this.bookService.getAllBooks(res);
            return books;
        });
    }

 
}

export default BookApplicationService;

_____________________________________________________________________________

Bookservice.ts 

 
import mongoose from 'mongoose';
import 'reflect-metadata';
import { inject, injectable } from 'inversify';
import BookRepository from './Book.repository';
import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware';
import { ClientSession } from 'mongoose';
import { Response } from 'express';

@injectable()
export class BookService {
    private bookRepository: BookRepository;

    constructor(@inject(BookRepository) bookRepository: BookRepository) {
        this.bookRepository = bookRepository;
    }

    @errorHandlerMiddleware
    async createBook(bookData: any, res: Response): Promise<any> {
        return this.bookRepository.createBook(bookData, res);
    }

 
    }

    @errorHandlerMiddleware
    async getAllBooks(res: Response): Promise<any> {
        return this.bookRepository.getAllBooks(res);
    }
}

export default BookService;




_____________________________________________________________________________
BookRepository.ts


import Book from './Book';
import mongoose from 'mongoose';
import { injectable } from 'inversify';
import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware';
import { ClientSession } from 'mongoose';
import { handleResponse } from '../../infrastructure/response';
import { Response } from 'express';

@injectable()
class BookRepository {
    @errorHandlerMiddleware
    async createBook(bookData: any, res: Response): Promise<any> {
        const responseData = {
            status: 201,
            data: { ...bookData },
            message: 'Book created successfully'
        };

        handleResponse(res, responseData.status, responseData.data, responseData.message);

        if (typeof bookData.stock === 'object' && bookData.stock !== null) {
            bookData.stock = bookData.stock.count;
        }

        const newBook = new Book(bookData);

        return newBook.save();
    }

    @errorHandlerMiddleware
    async getAllBooks(res: Response): Promise<any> {
        const books = await Book.find();

        const responseData = {
            status: 201,
            data: { ...books },
            message: 'Book listening successfully'
        };

        handleResponse(res, responseData.status, responseData.data, responseData.message);
        return books;
    }

  
    }
}

export default BookRepository;


_____________________________________________________________________________

Response.ts 


import { Response } from 'express';

export const handleResponse = (res: Response, statusCode: number, data: any, message: string = '') => {
    res.status(statusCode).json({
        status: statusCode,
        data: data,
        message: message
    });
};



_____________________________________________________________________________
Book.ts

import mongoose, { Document, Schema } from 'mongoose';
import Stock, { IStock } from '../BookStock/Stock.entity';
import BookLocation, { IBookLocation } from '../BookLocation/BookLocation';
import { number, string } from 'joi';

export interface IBook {
    title: string;
    author: string;
    stock: IStock;
    location: IBookLocation;
    status: string;
}

export interface IBookModel extends IBook, Document {}

const BookSchema: Schema = new Schema(
    {
        title: { type: String, required: true },
        author: { type: String, required: true },
        stock: { type: String, ref: 'Stock', required: true },
        location: {
            corridor: { type: String, required: true },
            shelf: { type: String, required: true },
            cupboard: { type: String, required: true }
        },
        status: { type: String, enum: ['Available', 'Borrowed'], default: 'Available' }
    },
    {
        timestamps: true,
        versionKey: false
    }
);

export default mongoose.model<IBookModel>('Book', BookSchema);

_____________________________________________________________________________

Stock.ts


import mongoose, { Document, Schema } from 'mongoose';

export interface IStock {
    count: number;
}

export interface IStockModel extends IStock, Document {}

const StockSchema: Schema = new Schema({
    count: { type: Number, required: true, default: 0 }
});

export default mongoose.model<IStockModel>('Stock', StockSchema);

_____________________________________________________________________________

location.ts


import mongoose, { Document, Schema } from 'mongoose';

export interface IBookLocation {
    corridor: string;
    shelf: string;
    cupboard: string;
}

export interface IBookLocationModel extends IBookLocation, Document {}

const BookLocationSchema: Schema = new Schema(
    {
        corridor: { type: String, required: true },
        shelf: { type: String, required: true },
        cupboard: { type: String, required: true }
    },
    {}
);

export default mongoose.model<IBookLocationModel>('BookLocation', BookLocationSchema);

_____________________________________________________________________________
