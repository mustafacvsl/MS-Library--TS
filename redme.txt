ExecutiveController.ts 


import { NextFunction, Request, Response } from 'express';
import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import Joi from 'joi';
import { handleResponse } from '../infrastructure/response';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';
import { ExecutiveApplicationService } from '../ApplicationService/ExecutiveApplicationService';

@injectable()
export class ExecutiveController {
    constructor(@inject('ExecutiveApplicationService') private executiveapplicationservice: ExecutiveApplicationService) {}

    borrowBook = async (req: Request, res: Response, next: NextFunction) => {
        const { memberId, bookId } = req.body;

        if (!memberId || !bookId) {
            handleResponse(res, 400, null, 'MemberId, bookId, borrowedDate, and dueDate are required.');
            return;
        }

        await this.executiveapplicationservice.borrowBook(memberId, bookId, res);
    };
}

_____________________________________________________________________________


ExecutiveApplicationService.ts 



import { inject, injectable } from 'inversify';
import 'reflect-metadata';
import { Response } from 'express';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';
import Joi from 'joi';
import TransactionHandler from '../infrastructure/Transaction/TransactionManager';
import ExecutiveService from '../Domain/Executive/executive.service';

@injectable()
export class ExecutiveApplicationService {
    constructor(@inject(ExecutiveService) private executiveservice: ExecutiveService, @inject(TransactionHandler) private transactionHandler: TransactionHandler) {}

    @errorHandlerMiddleware
    async borrowBook(memberId: string, bookId: string, res: Response): Promise<void> {
        return this.transactionHandler.runInTransaction(async (session) => {
            await this.executiveservice.borrowBook(memberId, bookId, res, session);
        });
    }
}

_____________________________________________________________________________


ExecutiveService.ts 


import { inject, injectable } from 'inversify';
import { Response } from 'express'; // Import Response from 'express'
import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware';
import { handleResponse } from '../../infrastructure/response';
import { addDays } from 'date-fns';
import { ClientSession } from 'mongoose';
import { ExecutiveRepository } from './executive.repository';
import authEntity, { IAuthorModel } from '../User/auth.entity';
import Book from '../Book/Book';
import memberEntity from '../Member/member.entity';

@injectable()
class ExecutiveService {
    constructor(@inject(ExecutiveRepository) private executiverepository: ExecutiveRepository) {}
    async borrowBook(memberId: string, bookId: string, res: Response, session: ClientSession): Promise<any> {
        const borrowedBook = await this.executiverepository.borrowBook(memberId, bookId, session);
        const member = await memberEntity.findById(memberId);
        const book = await Book.findById(bookId);

        if (!member || !book) {
            handleResponse(res, 404, null, 'Member or book not found');
            return;
        }

        handleResponse(res, 201, { loaned: borrowedBook, member, book }, 'Book borrowed successfully');
    }
}

export default ExecutiveService;

_____________________________________________________________________________

ExecutiveRepository.ts 


import mongoose, { ClientSession, Types } from 'mongoose';
import loanedEntity from '../Loaned/loaned.entity';
import AuthRepository from '../User/Auth.repository';

export class ExecutiveRepository {
    private client: mongoose.Mongoose;
    private databaseName: string;
    private authrepository: AuthRepository;

    constructor() {
        this.client = mongoose;
        this.databaseName = 'library';
        this.authrepository = new AuthRepository();
    }

    async borrowBook(memberId: string, bookId: string, session: ClientSession): Promise<any> {
        const loaned = new loanedEntity({
            memberId,
            bookId
        });

        return await loaned.save({ session });
    }
}

_____________________________________________________________________________

loanedEntity.ts 


import mongoose, { Document, Schema } from 'mongoose';
import memberEntity, { IMember } from '../Member/member.entity';
import Book, { IBook } from '../Book/Book';

export interface ILoaned {
    memberId: IMember;
    bookId: IBook;
}

export interface ILoanedModel extends ILoaned, Document {}

const LoanedSchema: Schema = new Schema(
    {
        memberId: { type: String, required: true, unique: true, ref: 'Member' },
        bookId: { type: String, required: true, unique: true, ref: 'Book' }
    },
    {
        versionKey: false
    }
);

export default mongoose.model<ILoanedModel>('Loaned', LoanedSchema);


_____________________________________________________________________________