AuthController.ts

import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware'; import { NextFunction, Request, Response, Router } from 'express'; import container from '../infrastructure/inversify';
import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { AuthApplicationService } from '../ApplicationService/AuthApplicationService'; import { handleResponse } from
'../infrastructure/response'; import Book, { IBook } from '../Domain/Book/Book';

@injectable() export class AuthController { constructor(@inject('AuthApplicationService') private authApplicationService: AuthApplicationService) {}

    @errorHandlerMiddleware
    async register(req: Request, res: Response): Promise<void> {
        const { name, email, password } = req.body;
        const result = await this.authApplicationService.registerUser(name, email, password, res);

        handleResponse(res, 201, { user: result }, 'User registered successfully');
    }

    @errorHandlerMiddleware
    async listBooksUsers(req: Request, res: Response): Promise<void> {
        const books = await this.authApplicationService.listBooksUsers(res);

        handleResponse(res, 200, { books }, 'Books listed for users');
    }

    @errorHandlerMiddleware
    async login(req: Request, res: Response): Promise<void> {
        const { email, password } = req.body;
        const result = await this.authApplicationService.loginUser(email, password, res);

        handleResponse(res, 200, { user: result }, 'Login successful');
    }

}

---

AuthAPplicationService.ts

import AuthService from '../Domain/User/Auth.service'; import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { errorHandlerMiddleware } from
'../middleware/errorhandlerMiddleware'; import { Request, Response } from 'express'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager';

@injectable() export class AuthApplicationService { constructor(@inject(AuthService) private authService: AuthService, @inject(TransactionHandler) private transactionhandler: TransactionHandler) {}

    @errorHandlerMiddleware
    async registerUser(name: string, email: string, password: string, res: Response): Promise<void> {
        const user = await this.authService.registerUser(name, email, password, res);

        res.status(201).json({ user });
    }

    @errorHandlerMiddleware
    async listBooksUsers(res: Response): Promise<void> {
        await this.transactionhandler.runInTransaction(async (session) => {
            const books = await this.authService.listBooksUsers();

            res.status(200).json({
                books
            });
        });
    }

    @errorHandlerMiddleware
    async loginUser(email: string, password: string, res: Response): Promise<void> {
        const user = await this.authService.login(email, password, res);

        res.status(200).json({
            user
        });
    }

}

export default AuthApplicationService;

---

AuthService.ts

import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { Response } from 'express'; import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware'; import
{ promisify } from 'util'; const jwt = require('jsonwebtoken'); import AuthRepository from './Auth.repository'; import { IAuthorModel } from './auth.entity'; import { handleResponse } from
'../../infrastructure/response'; import { getConfig } from '../../infrastructure/config';

const compareAsync = promisify(require('bcrypt').compare); const hashAsync = promisify(require('bcrypt').hash);

@injectable() class AuthService { private readonly config = getConfig();

    constructor(@inject(AuthRepository) private authrepository: AuthRepository) {}

    @errorHandlerMiddleware
    async registerUser(name: string, email: string, password: string, res: Response): Promise<any> {
        if (typeof password !== 'string') {
            throw new Error('Password must be a string');
        }

        const existingUser = await this.authrepository.findUserByEmail(email);
        if (existingUser) {
            throw new Error('User with this email already exists');
        }

        const hashedPassword = await hashAsync(password + 'sadasdda' + name, 10);
        const user = await this.authrepository.registerUser(name, email, hashedPassword);

        return user;
    }

    @errorHandlerMiddleware
    async listBooksUsers(): Promise<unknown[]> {
        return this.authrepository.getAllBooks();
    }

    @errorHandlerMiddleware
    async login(email: string, password: string, res: Response): Promise<any> {
        const user = await this.authrepository.loginUser(email);

        if (!user) {
            throw new Error('Invalid credentials');
        }

        const passwordMatch = await compareAsync(password, user.password);
        if (!passwordMatch) {
            throw new Error('Authentication failed');
        }

        const token = this.generateToken(user);

        res.status(200).json({
            token,
            message: 'Login successful'
        });
    }
    private generateToken(user: IAuthorModel): string {
        const expiresIn = '1h';

        const payload = {
            userId: user._id,
            email: user.email
        };

        const token = jwt.sign(payload, this.config.secretKey, { expiresIn });
        return token;
    }

}

export default AuthService;

---

AuthRepository.ts

import { injectable } from 'inversify'; import authEntity, { IAuthorModel } from './auth.entity'; import Book, { IBookModel } from '../Book/Book';

@injectable() class AuthRepository { async findUserByEmail(email: string): Promise<IAuthorModel | null> { return authEntity.findOne({ email }).exec(); }

    async registerUser(name: string, email: string, hashedPassword: string): Promise<IAuthorModel> {
        const user = new authEntity({ name, email, password: hashedPassword });
        return user.save();
    }

    async getAllBooks(): Promise<IBookModel[]> {
        return Book.find({}).exec();
    }

    async findUserById(userId: string): Promise<IAuthorModel | null> {
        return authEntity.findById(userId).exec();
    }

    async loginUser(email: string): Promise<IAuthorModel | null> {
        return authEntity.findOne({ email }).exec();
    }

}

export default AuthRepository;

---

AuthRoutes.ts

import express from 'express'; import { AuthController } from '../Controller/auth.controller'; import { Schemas, JoiMiddleware } from '../middleware/JoiMiddleware'; import { AuthApplicationService }
from '../ApplicationService/AuthApplicationService'; import container from '../infrastructure/inversify'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager'; import
AuthService from '../Domain/User/Auth.service'; import AuthRepository from '../Domain/User/Auth.repository'; const router = express.Router();

const authController = container.get<AuthController>(AuthController);

router.post('/register', authController.register.bind(authController)); router.post('/login', authController.login.bind(authController)); router.get('/getbooks',
authController.listBooksUsers.bind(authController));

export = router;

---

BookController.ts

import { NextFunction, Request, Response } from 'express'; import 'reflect-metadata'; import { inject, injectable } from 'inversify'; import BookApplicationService from
'../ApplicationService/BookApplicationService'; import { handleResponse } from '../infrastructure/response'; import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';

@injectable() export class BookController { private bookApplicationservice: BookApplicationService;

    constructor(@inject(BookApplicationService) bookApplicationservice: BookApplicationService) {
        this.bookApplicationservice = bookApplicationservice;
    }

    createBook = async (req: Request, res: Response, next: NextFunction) => {
        const { title, author, stock, location } = req.body;

        const newBook = await this.bookApplicationservice.createBook(
            {
                title,
                author,
                stock,
                location
            },
            res
        );

        handleResponse(res, 201, { book: newBook }, 'Book created successfully');
    };

    showAllBooks = async (req: Request, res: Response, next: NextFunction) => {
        const allBooks = await this.bookApplicationservice.showAllBooks(res);
        handleResponse(res, 200, { books: allBooks }, 'List of all books');
    };

    updateBook = async (req: Request, res: Response, next: NextFunction) => {
        const { bookId } = req.params;
        const updatedData = req.body;
        await this.bookApplicationservice.updateBook(bookId, updatedData, res);
        handleResponse(res, 200, null, 'Book updated successfully');
    };

    deleteBook = async (req: Request, res: Response, next: NextFunction) => {
        const { bookId } = req.params;
        await this.bookApplicationservice.deleteBook(bookId, res);
        handleResponse(res, 204, null, 'Book deleted successfully');
    };

}

export default BookController;

---

BookApplicationService.ts

import BookService from '../Domain/Book/Book.service'; import Book, { IBook } from '../Domain/Book/Book'; import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { Response }
from 'express'; import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager'; @injectable() export
class BookApplicationService { private bookService: BookService; private transactionHandler: TransactionHandler;

    constructor(@inject(BookService) bookService: BookService, @inject(TransactionHandler) transactionHandler: TransactionHandler) {
        this.bookService = bookService;
        this.transactionHandler = transactionHandler;
    }

    @errorHandlerMiddleware
    async createBook(bookData: { title: string; author: string; stock: string; location: { corridor: string; shelf: string; cupboard: string } }, res: Response): Promise<void | null> {
        return this.transactionHandler.runInTransaction(async (session) => {
            const newBook = await this.bookService.createBook(bookData, res, session);

            if (newBook) {
                res.status(201).json({ book: newBook });
            } else {
                res.status(500).json({ message: 'Failed to create the book' });
            }
        });
    }

    @errorHandlerMiddleware
    async showAllBooks(res: Response): Promise<any> {
        return this.transactionHandler.runInTransaction(async () => {
            const allBooks = await this.bookService.showAllBooks();
            return allBooks;
        });
    }

    @errorHandlerMiddleware
    async updateBook(bookId: string, updatedBookInfo: any, res: Response): Promise<void | null> {
        return this.transactionHandler.runInTransaction(async (session) => {
            return this.bookService.updateBook(bookId, updatedBookInfo, res, session);
        });
    }

    @errorHandlerMiddleware
    async deleteBook(bookId: string, res: Response): Promise<void | null> {
        return this.transactionHandler.runInTransaction(async (session) => {
            return this.bookService.deleteBook(bookId, res, session);
        });
    }

}

export default BookApplicationService;

---************************\*\*\*\*************************\_\_\_************************\*\*\*\************************* BookService.ts

import mongoose from 'mongoose'; import 'reflect-metadata'; import { inject, injectable } from 'inversify'; import BookRepository from './Book.repository'; import { Response } from 'express'; import {
errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware'; import { ClientSession } from 'mongoose';

@injectable() export class BookService { private bookRepository: BookRepository;

    constructor(@inject(BookRepository) bookRepository: BookRepository) {
        this.bookRepository = bookRepository;
    }

    @errorHandlerMiddleware
    async createBook(
        bookData: { title: string; author: string; stock: string; location: { corridor: string; shelf: string; cupboard: string } },
        res: Response,
        session?: ClientSession
    ): Promise<any> {
        return this.bookRepository.createBook(bookData);
    }

    @errorHandlerMiddleware
    async showAllBooks(): Promise<any> {
        return this.bookRepository.showAllBooks();
    }

    @errorHandlerMiddleware
    async updateBook(bookId: string, updatedBookInfo: any, res: Response, session: ClientSession | null = null): Promise<any> {
        if (!bookId) {
            throw new Error('Book ID is required.');
        }
        return this.bookRepository.updateBook(bookId, updatedBookInfo);
    }

    @errorHandlerMiddleware
    async deleteBook(bookId: string, res: Response, session: ClientSession | null = null): Promise<any> {
        if (!bookId) {
            throw new Error('Book ID required.');
        }
        return this.bookRepository.deleteBook(bookId);
    }

}

export default BookService;

---

BookRepository.ts

import Book from './Book'; import mongoose from 'mongoose'; import { injectable } from 'inversify'; import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware'; import {
ClientSession } from 'mongoose';

@injectable() class BookRepository { @errorHandlerMiddleware async createBook(bookData: { title: string; author: string; stock: string; location: { corridor: string; shelf: string; cupboard: string }
}): Promise<any> { if (!bookData.author || !bookData.title) throw new Error('Author and title are required.');

        const newBook = await Book.create({
            author: bookData.author,
            title: bookData.title,
            stock: bookData.stock,
            location: bookData.location
        });
        return newBook.save();
    }

    @errorHandlerMiddleware
    async showAllBooks(): Promise<any> {
        return Book.find();
    }

    @errorHandlerMiddleware
    async updateBook(bookId: string, updatedBookInfo: any): Promise<any> {
        return Book.findByIdAndUpdate(bookId, updatedBookInfo, { new: true }).orFail(new Error('Book not found'));
    }

    @errorHandlerMiddleware
    async deleteBook(bookId: string): Promise<any> {
        const book = await Book.findByIdAndDelete(bookId);

        if (!book) {
            throw new Error('Book not found');
        }

        return book;
    }

}

export default BookRepository;

---

BookRoutes.ts

import express from 'express'; import { BookController } from '../Controller/book.controller'; import BookApplicationService from '../ApplicationService/BookApplicationService'; import BookService
from '../Domain/Book/Book.service'; import BookRepository from '../Domain/Book/Book.repository'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager'; import container
from '../infrastructure/inversify';

const router = express.Router();

const bookController = container.get<BookController>(BookController);

router.post('/create', bookController.createBook.bind(bookController)); router.patch('/update/:bookId', bookController.updateBook.bind(bookController)); router.delete('/delete/:bookId',
bookController.deleteBook.bind(bookController));

router.get('/showAll', bookController.showAllBooks.bind(bookController));

export = router;

---

ExecutiveController.ts

import { NextFunction, Request, Response } from 'express'; import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import Joi from 'joi'; import { handleResponse } from
'../infrastructure/response'; import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware'; import { ExecutiveApplicationService } from
'../ApplicationService/ExecutiveApplicationService';

@injectable() export class ExecutiveController { constructor(@inject('ExecutiveApplicationService') private executiveapplicationservice: ExecutiveApplicationService) {}

    @errorHandlerMiddleware
    async listUsers(req: Request, res: Response, next: NextFunction) {
        const users = await this.executiveapplicationservice.listUsers(res);
        handleResponse(res, 200, { users }, 'Users listed successfully');
    }

    @errorHandlerMiddleware
    async updateUsers(req: Request, res: Response, next: NextFunction) {
        const userId = req.params.userId;
        const data = req.body;
        const updatedUser = await this.executiveapplicationservice.updateUsers(userId, data, res);
        handleResponse(res, 200, { updatedUser }, 'User updated successfully');
    }

    @errorHandlerMiddleware
    async deleteUsers(req: Request, res: Response, next: NextFunction) {
        const userId = req.params.userId;
        const deletedUser = await this.executiveapplicationservice.deleteUsers(userId, res);
        handleResponse(res, 200, { deletedUser }, 'User deleted successfully');
    }

    @errorHandlerMiddleware
    async borrowBook(req: Request, res: Response, next: NextFunction) {
        const { memberId, bookId, borrowedDate, returnedDate } = req.body;

        const loanedBook = await this.executiveapplicationservice.borrowBook(memberId, bookId, borrowedDate, returnedDate, res);
        handleResponse(res, 201, { loanedBook });
    }

    @errorHandlerMiddleware
    async returnBook(req: Request, res: Response, next: NextFunction) {
        const loanId = req.params.loanId;

        const returnedBook = await this.executiveapplicationservice.returnBook(loanId, res);
        handleResponse(res, 201, { returnedBook });
    }

}

---

---

ExecutiveApplicationService.ts

import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { Response } from 'express'; import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware'; import Joi
from 'joi'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager'; import ExecutiveService from '../Domain/Executive/executive.service';

@injectable() export class ExecutiveApplicationService { constructor(@inject(ExecutiveService) private executiveservice: ExecutiveService, @inject(TransactionHandler) private transactionHandler:
TransactionHandler) {}

    @errorHandlerMiddleware
    async listUsers(res: Response) {
        return this.transactionHandler.runInTransaction(async (session) => {
            const users = await this.executiveservice.listUsers();
            res.status(200).json({ users });
        });
    }

    @errorHandlerMiddleware
    async updateUsers(userId: string, data: any, res: Response) {
        return this.transactionHandler.runInTransaction(async (session) => {
            const updatedUser = await this.executiveservice.updateUsers(userId, data);
            res.status(200).json({ updatedUser });
        });
    }

    @errorHandlerMiddleware
    async deleteUsers(userId: string, res: Response) {
        return this.transactionHandler.runInTransaction(async (session) => {
            const deletedUser = await this.executiveservice.deleteUsers(userId);
            res.status(200).json({ deletedUser });
        });
    }

    @errorHandlerMiddleware
    async borrowBook(memberId: string, bookId: string, borrowedDate: Date, returnedDate: Date, res: Response) {
        return this.transactionHandler.runInTransaction(async (session) => {
            return this.executiveservice.borrowBook(memberId, bookId, borrowedDate, returnedDate, session);
        });
    }

    @errorHandlerMiddleware
    async returnBook(loanId: string, res: Response) {
        return this.transactionHandler.runInTransaction(async (session) => {
            return this.executiveservice.returnBook(loanId, session);
        });
    }

}

---

ExecutiveService.ts

import { inject, injectable } from 'inversify'; import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware'; import { handleResponse } from '../../infrastructure/response'; import
{ addDays } from 'date-fns'; import { ClientSession } from 'mongoose'; import ExecutiveRepository from './executive.repository';

@injectable() class ExecutiveService { constructor(@inject(ExecutiveRepository) private executiverepository: ExecutiveRepository) {}

    @errorHandlerMiddleware
    async listUsers(): Promise<any> {
        return this.executiverepository.listUsers();
    }

    @errorHandlerMiddleware
    async updateUsers(userId: string, data: any): Promise<any> {
        return this.executiverepository.updateUsers(userId, data);
    }

    @errorHandlerMiddleware
    async deleteUsers(userId: string): Promise<any> {
        return this.executiverepository.deleteUsers(userId);
    }

    @errorHandlerMiddleware
    async borrowBook(memberId: string, bookId: string, borrowedDate: Date, returnedDate: Date, session: ClientSession): Promise<any> {
        return this.executiverepository.borrowBookWithPenalty(memberId, bookId, borrowedDate, returnedDate, session);
    }

    @errorHandlerMiddleware
    async returnBook(loanId: string, session: ClientSession): Promise<any> {
        return this.executiverepository.returnBook(loanId, session);
    }

}

export default ExecutiveService;

---

ExecutiveRepository.ts

import mongoose, { ClientSession } from 'mongoose'; import Book, { IBook } from '../Book/Book'; import loanedEntity, { ILoanedModel } from '../Loaned/loaned.entity'; import StockEntity, { IStock }
from '../BookStock/Stock.entity'; import authEntity, { IAuthorModel } from '../User/auth.entity'; import { addDays } from 'date-fns';

class ExecutiveRepository { private client: mongoose.Mongoose; private databaseName: string;

    constructor() {
        this.client = mongoose;
        this.databaseName = 'library';
    }

    async findUserByEmail(email: string) {
        return authEntity.findOne({ email });
    }

    async findUserById(userId: string) {
        return authEntity.findById(userId);
    }

    async listUsers(): Promise<IAuthorModel[]> {
        const users = await authEntity.find({}, '-password').exec();
        return users;
    }

    async updateUsers(userId: string, data: any): Promise<IAuthorModel | null> {
        const updatedUser = await authEntity.findByIdAndUpdate(userId, data, { new: true }).exec();
        return updatedUser;
    }

    async deleteUsers(userId: string): Promise<IAuthorModel | null> {
        const deletedUser = await authEntity.findByIdAndDelete(userId).exec();
        return deletedUser;
    }

    async borrowBookWithPenalty(memberId: string, bookId: string, borrowedDate: Date, returnedDate: Date, session: ClientSession): Promise<ILoanedModel | null> {
        const options = { session };

        try {
            const overdueLoan = await loanedEntity.findOne(
                {
                    memberId,
                    returnedDate: null,
                    borrowedDate: { $lt: addDays(new Date(), -90) }
                },
                options
            );

            if (overdueLoan) {
                throw new Error('User has overdue books. Cannot borrow until overdue books are returned.');
            }

            const book = await Book.findById(bookId, null, options);

            if (!book) {
                throw new Error('Book not found');
            }

            if (book.stock.count <= 0) {
                throw new Error('Book out of stock');
            }

            const stockEntry = new StockEntity({
                bookId,
                transactionType: 'entry',
                count: 1,
                timestamp: new Date()
            });

            await stockEntry.save(options);

            book.stock.count = Number(book.stock.count) - 1;
            await book.save(options);

            const loanedBook = new loanedEntity({
                memberId,
                bookId,
                borrowedDate: new Date(),
                returnedDate: null
            });

            const savedLoan = await loanedBook.save(options);

            return savedLoan;
        } catch (error) {
            throw error;
        }
    }

    async returnBook(loanId: string, session: ClientSession): Promise<ILoanedModel | null> {
        const options = { session };

        try {
            const loanedBook = await loanedEntity.findById(loanId, options);

            if (!loanedBook) {
                throw new Error('Loan not found');
            }

            if (loanedBook.returnedDate) {
                throw new Error('Book already returned');
            }

            loanedBook.returnedDate = new Date();

            const stockEntry = new StockEntity({
                bookId: loanedBook.bookId,
                transactionType: 'entry',
                count: 1,
                timestamp: new Date()
            });

            await stockEntry.save(options);

            const updatedLoan = await loanedBook.save(options);

            return updatedLoan;
        } catch (error) {
            throw error;
        }
    }

}

export default ExecutiveRepository;

---

ExecutiveRoutes.ts

import express from 'express'; import { ExecutiveController } from '../Controller/executive.controller'; import { Schemas, JoiMiddleware } from '../middleware/JoiMiddleware';

import container from '../infrastructure/inversify';

const executivecontroller = container.get<ExecutiveController>(ExecutiveController);

const router = express.Router();

router.get('/list', executivecontroller.listUsers.bind(executivecontroller)); router.patch('/update/:authorId', executivecontroller.updateUsers.bind(executivecontroller));
router.delete('/delete/:authorId', executivecontroller.deleteUsers.bind(executivecontroller)); router.post('/return-book', executivecontroller.returnBook.bind(executivecontroller));
router.post('/borrow-book', JoiMiddleware(Schemas.executive.borrowBook), executivecontroller.borrowBook.bind(executivecontroller)); export = router;

---

MemberController.ts

import { NextFunction, Request, Response } from 'express'; import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { isValidEmail } from '../infrastructure/validEmail';
import { MemberApplicationService } from '../ApplicationService/MemberApplicationService'; import { handleResponse } from '../infrastructure/response';

@injectable() export class MemberController { constructor(@inject('MemberApplicationService') private memberApplicationService: MemberApplicationService) {}

    async addMember(req: Request, res: Response, next: NextFunction): Promise<void> {
        try {
            const { name, email } = req.body;

            if (!name || !email) {
                handleResponse(res, 400, null, 'Name and email are required.');
                return;
            }

            if (!isValidEmail(email)) {
                handleResponse(res, 400, null, 'Invalid email address.');
                return;
            }

            const addedMember = await this.memberApplicationService.addMember(name, email, res);

            handleResponse(res, 201, { member: addedMember }, 'Member added successfully');
        } catch (error) {
            console.error('Error:', error);
            handleResponse(res, 500, null, 'Internal Server Error');
        }
    }

}

---

MemberApplicationService.ts

import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware'; import { Response } from 'express'; import
TransactionHandler from '../infrastructure/Transaction/TransactionManager'; import MemberService from '../Domain/Member/member.service';

@injectable() export class MemberApplicationService { constructor(@inject(MemberService) private memberService: MemberService, @inject(TransactionHandler) private transactionHandler:
TransactionHandler) {}

    @errorHandlerMiddleware
    async addMember(name: string, email: string, res: Response): Promise<void> {
        await this.transactionHandler.runInTransaction(async (session) => {
            const addedMember = await this.memberService.addMember(name, email, session);

            res.status(201).json({ member: addedMember, message: 'Member added successfully' });
        });
    }

}

---

MemberService.ts

import { inject, injectable } from 'inversify'; import 'reflect-metadata'; import MemberEntity from './member.entity'; import MemberRepository from './member.repository'; import { Response } from
'express'; import { ClientSession } from 'mongoose'; import { errorHandlerMiddleware } from '../../middleware/errorhandlerMiddleware'; import AuthRepository from '../User/Auth.repository'; import {
isValidEmail } from '../../infrastructure/validEmail';

@injectable() export class MemberService { constructor(@inject(MemberRepository) private memberRepository: MemberRepository, @inject(AuthRepository) private authRepository: AuthRepository) {}

    @errorHandlerMiddleware
    async addMember(name: string, email: string, res: Response, session: ClientSession): Promise<any> {
        if (!isValidEmail(email)) {
            res.status(400).json({ message: 'Geçersiz e-posta adresi' });
            return;
        }

        const emailExists = await this.memberRepository.emailExists(email, session);

        if (emailExists) {
            res.status(400).json({ message: 'Bu e-posta ile zaten bir üye mevcut' });
            return;
        }

        const existingMember = await this.memberRepository.findMemberByEmail(email, session);
        if (existingMember) {
            res.status(400).json({ message: 'Bu e-posta ile zaten bir üye mevcut' });
            return;
        }

        const userExists = await this.authRepository.findUserByEmail(email);
        if (!userExists) {
            res.status(400).json({ message: 'Bu e-posta ile kayıtlı bir kullanıcı bulunamadı. Lütfen önce kullanıcı olarak kaydolun.' });
            return;
        }

        const addedMember = await this.memberRepository.addMember(name, email, session);
        res.status(201).json({ member: addedMember, message: 'Üye başarıyla eklendi' });
    }

}

export default MemberService;

---

MemberRepository.ts

import MemberEntity from './member.entity'; import { ClientSession } from 'mongoose';

export class MemberRepository { async findMemberByEmail(email: string, session: ClientSession) { return MemberEntity.findOne({ email }).session(session); }

    async addMember(name: string, email: string, session: ClientSession) {
        const member = new MemberEntity({
            name,
            email
        });

        return await member.save({ session });
    }

    async emailExists(email: string, session: ClientSession): Promise<boolean> {
        const member = await this.findMemberByEmail(email, session);
        return !!member;
    }

}

export default MemberRepository;

---

---

MemberRoutes.ts

import express, { Router, Request, Response, NextFunction } from 'express'; import { MemberController } from '../Controller/Member.controller'; import { MemberApplicationService } from
'../ApplicationService/MemberApplicationService'; import TransactionHandler from '../infrastructure/Transaction/TransactionManager'; import MemberService from '../Domain/Member/member.service'; import
MemberRepository from '../Domain/Member/member.repository'; import AuthRepository from '../Domain/User/Auth.repository'; import container from '../infrastructure/inversify';

const memberRouter: Router = express.Router();

const memberController = container.get<MemberController>(MemberController);

memberRouter.post('/add', async (req: Request, res: Response, next: NextFunction) => { await memberController.addMember(req, res); });

export default memberRouter;

---

errorHandleMiddleware.ts

import { Request, Response, NextFunction } from 'express';

export function errorHandlerMiddleware(target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor { const originalMethod = descriptor.value;

    descriptor.value = async function (req: Request, res: Response, next: NextFunction): Promise<void> {
        try {
            await originalMethod.call(this, req, res, next);
        } catch (error) {
            console.error('Error:', error);
            if (res && res.status) {
                res.status(500).send('Internal Server Error');
            } else {
                console.error('Response object does not have a status function.');
            }
        }
    };

    return descriptor;

}

---

Response.ts

import { Response } from 'express';

export const handleResponse = (res: Response, statusCode: number, data: any, message: string = '') => { res.status(statusCode).json({ status: statusCode, data: data, message: message }); };

---

Joi.ts

import Joi, { ObjectSchema } from 'joi'; import { NextFunction, Request, Response } from 'express'; import { IAuthor } from '../Domain/User/auth.entity'; import { IBook } from '../Domain/Book/Book';
import memberEntity, { IMember } from '../Domain/Member/member.entity'; import Logging from '../infrastructure/Logging'; import { ILoanedModel } from '../Domain/Loaned/loaned.entity';

export const JoiMiddleware = (schema: ObjectSchema) => { return async (req: Request, res: Response, next: NextFunction) => { try { await schema.validateAsync(req.body);

            next();
        } catch (error) {
            Logging.error(error);

            return res.status(422).json({ error });
        }
    };

};

export const Schemas = { author: { create: Joi.object<IAuthor>({ name: Joi.string().required(), email: Joi.string().email().required(), password: Joi.string().required() }) }, book: { create:
Joi.object<IBook>({ author: Joi.string().required(), title: Joi.string().required() // stock: Joi.string().required, // location: Joi.string().required }), update: Joi.object<IBook>({ author:
Joi.string().required(), title: Joi.string().required() }) },

    executive: {
        borrowBook: Joi.object({
            memberId: Joi.string().required(),
            bookId: Joi.string().required()
        })
    }

};

---

inversify.ts

import { Container } from 'inversify'; import { AuthController } from '../Controller/auth.controller'; import { BookController } from '../Controller/book.controller'; import AuthService from
'../Domain/User/Auth.service'; import BookService from '../Domain/Book/Book.service'; import BookApplicationService from '../ApplicationService/BookApplicationService'; import AuthRepository from
'../Domain/User/Auth.repository'; import BookRepository from '../Domain/Book/Book.repository'; import { AuthApplicationService } from '../ApplicationService/AuthApplicationService'; import
ExecutiveService from '../Domain/Executive/executive.service'; import { ExecutiveApplicationService } from '../ApplicationService/ExecutiveApplicationService'; import { ExecutiveController } from
'../Controller/executive.controller'; import { MemberController } from '../Controller/Member.controller'; import { MemberApplicationService } from '../ApplicationService/MemberApplicationService';
import MemberService from '../Domain/Member/member.service'; import MemberRepository from '../Domain/Member/member.repository'; import TransactionHandler from './Transaction/TransactionManager';
import { errorHandlerMiddleware } from '../middleware/errorhandlerMiddleware';

const container = new Container(); container.bind<TransactionHandler>(TransactionHandler).toSelf(); container.bind<AuthApplicationService>(AuthApplicationService).toSelf();
container.bind<AuthController>(AuthController).toSelf(); container.bind<BookController>(BookController).toSelf(); container.bind<AuthService>(AuthService).toSelf();
container.bind<BookService>(BookService).toSelf(); container.bind<BookApplicationService>(BookApplicationService).toSelf(); container.bind<AuthRepository>(AuthRepository).toSelf();
container.bind<BookRepository>(BookRepository).toSelf(); container.bind<ExecutiveService>(ExecutiveService).toSelf(); container.bind<ExecutiveApplicationService>(ExecutiveApplicationService).toSelf();
container.bind<ExecutiveController>(ExecutiveController).toSelf(); container.bind<MemberApplicationService>(MemberApplicationService).toSelf();
container.bind<MemberController>(MemberController).toSelf(); container.bind<MemberService>(MemberService).toSelf(); container.bind<MemberRepository>(MemberRepository).toSelf();

export default container;

---

Transaction.ts

import { injectable } from 'inversify'; import mongoose, { ClientSession } from 'mongoose';

@injectable() export default class TransactionHandler { private client: mongoose.Mongoose;

    constructor() {
        this.client = mongoose;
    }

    async runInTransaction(callback: (session: ClientSession) => Promise<void>): Promise<void> {
        const session = await this.client.startSession();
        session.startTransaction();

        try {
            await callback(session);
            await session.commitTransaction();
        } catch (error) {
            await session.abortTransaction();
            throw error;
        } finally {
            session.endSession();
        }
    }

}

---
